import json
import os
import time
from collections import defaultdict
from telegram import Bot
import asyncio
import requests
import sys

# exposing vaultwarden password manager is dangerous
# it is a good practice to protect the access using a firewall and/or a VPN
# but even there it can be useful to monitor requests and be sure no one gains access
# this script uses logs generated by caddy to detect accesses and notify the user via telegram bot
# this script must be run by root, and within apython virtual envirnment containing python-telegram-bot module


# bot parameters
TELEGRAM_BOT_TOKEN = os.getenv("MY_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")
bot = Bot(token=TELEGRAM_BOT_TOKEN)

# bot send message
async def send_message(text, chat_id):
    async with bot:
        await bot.send_message(text=text, chat_id=chat_id) 

async def run_bot(messages, chat_id):
    text = ' '.join(messages)
    await send_message(text, chat_id)

def new_ip_entry():
    return {
            "first_access": None,
            "uris": []
    }

def get_ipinfo(ip):
    try:
        res = requests.get(f'https://ipinfo.io/{ip}',timeout=5)
    
        res.raise_for_status()
    
        #response = json.loads(res.content.decode('utf-8'))
    
        data = res.json()
        city = data.get('city','Error retrieving city')
        region = data.get('region','Error retrieving region')


        return f"{city}, {region}"
    except requests.exceptions.Timeout:
        return f"Request timed out"
    except requests.exceptions.HTTPError as e:
        return f"HTTP error {e}"
    except requests.exceptions.RequestException as e:
        return f"Network error {e}"
    except (json.JSONDecodeError,KeyError):
        return f"Invalid reponse format"
    except Exception as e:
        return f"Unexpected exception {e}"

# check if user has privileges
if os.geteuid() != 0:
    print("This script must be executed as root")
    exit(1)

# go to log directory
os.chdir('/var/log/caddy/')

#log file
filename = 'vaultwarden-access.log'

old_size = 0
last_pos = 0

while True:
    cur_size = os.path.getsize(filename)

    if cur_size != old_size and cur_size > 0:
        old_size = cur_size
        with open(filename,'r') as f:
            f.seek(last_pos)
            lines = f.readlines()
            last_pos= f.tell()
            
        dic = defaultdict(new_ip_entry)

        for line in lines:
            try:
                el = json.loads(line)
                ip = el['request']['client_ip']
                ts = el['ts']
                uri = el['request']['uri']
                dic[ip]['uris'].append(uri)
                if dic[ip]['first_access'] is None:
                    dic[ip]['first_access'] = ts 
            except json.JSONDecodeError:
                continue
        
        messages = []
        for ip,infos in dic.items():
            ip_details = get_ipinfo(ip)
            message = f"Ip {ip} ({ip_details}) accessed at {infos['first_access']} at uris: {infos['uris']}\n" 
            messages.append(message)
            # print(message)
        message_size = sum(sys.getsizeof(m) for m in messages)
        if message_size > 4096:
            messages=messages[-1:]
            messages.append('Other IPs were detected but message was too long. Only last acces is being displayed')
        asyncio.run(run_bot(messages,CHAT_ID))
    #else:
    #   print("Nothing new this round")

    time.sleep(4)
